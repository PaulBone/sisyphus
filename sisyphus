#!/usr/bin/env python
from copy                    import deepcopy
from datetime                import datetime
from glob                    import iglob as glob
from test.test               import ensure_dir, annotated_test_factories, Environment
from urllib                  import urlopen
from util.concurrent.futures import ThreadPoolExecutor
import fnmatch
import imp
import multiprocessing
import argparse
import os
import sys
import traceback
import logging

_version        = "0.2"
_report_name    = "stats-" + datetime.now().strftime("%Y.%m.%d")
_configurations = dict()
_out            = sys.stdout

_default_environment = Environment(
    arch_dirs        = [],
    builddir         = "build/",
    debug            = False,
    default_dirs     = [],
    expect_url       = "",
    faillog_out      = None,
    reportdir        = "reports/",
    runexe           = "",
    show_disappeared = False,
    tests            = ["."],
    threads          = multiprocessing.cpu_count() + 1,
    verbose          = False,
)

_argparser = argparse.ArgumentParser()
_argparser.add_argument(dest="tests", metavar="TEST", nargs="*",
                        help="test to run")
_argparser.add_argument("-d", "--debug", dest="debug", action="store_true",
                        help="Enable debug messages")
_argparser.add_argument("-v", "--verbose", dest="verbose", action="store_true",
                        help="More output")
_argparser.add_argument("-c", "--compile-times", dest="compile_times",
                        action="store_true",
                        help="Display compile time of each program")
_argparser.add_argument("-t", "--threads", dest="threads", type=int,
                        help="Number of threads to use")
_argparser.add_argument("--faillog", dest="faillog_out",
                        help="Write faillog into file specified here")
_argparser.add_argument("--expect", dest="expect_url",
                        help="file/url with fail expectations")
_argparser.add_argument("--show-disappeared", dest="show_disappeared",
                        action="store_true", help="show disappeared tests")
_argparser.add_argument("--version", action="version", version=_version)

# List of (matchfunc, factory) tuples.
# if matchfunc(filename) returns True then factory(filename, environment) will
# be used to construct a Test for this file.
_test_factories = []

_console_red    = "\033[1;31m"
_console_green  = "\033[1;32m"
_console_yellow = "\033[1;33m"
_console_bold   = "\033[1m"
_console_normal = "\033[m"
_console_clear  = "\r\033[K"
_rc             = 0  # application return code


def load_expectations(url, environment):
    try:
        fetched = True
        input   = urlopen(url)
        if input.getcode() is not None and input.getcode() != 200:
            fetched = False
    except:
        fetched = False

    cachefile = environment.builddir + "/" + os.path.basename(url)
    if not fetched:
        _out.write("Warning: Couldn't download from '%s', using cache file\n"
                   % url)
        input = open(cachefile)

    results = dict()
    for line in input:
        line = line.decode("utf-8")
        try:
            i = line.index(" ")
        except ValueError:
            continue
        test_id          = line[:i]
        result           = line[i:].strip()
        results[test_id] = result

    cache = open(cachefile, "w")
    for (test_id, result) in results.iteritems():
        cache.write("%-40s %s\n" % (test_id, result))
    cache.close()

    return results


def expectation_match(error, expectation):
    if error.endswith(" compile errors") and \
       expectation.endswith(" compile errors"):
        # exact number of compile errors does not matter
        return True
    if error == "compile: SIGXCPU" and expectation == "compile: SIGKILL" or \
       error == "execute: SIGXCPU" and expectation == "execute: SIGKILL":
        # BSD on timeout signals SIGXCPU and Linux SIGKILL
        return True
    if error == "compile: SIGBUS" and expectation == "compile: SIGSEGV" or \
       error == "execute: SIGBUS" and expectation == "execute: SIGSEGV":
        # OS X often signals SIGBUS where others signal SIGSEGV
        return True
    return error == expectation


def console_output(config, test, expected):
    timing = ""
    prefix = ""
    if config.compile_times:
        time = None
        if hasattr(test, "stepresults") and "compile" in test.stepresults:
            result = test.stepresults["compile"]
            if hasattr(result, "time"):
                time = result.time
        if time is not None:
            timing = " [%s%.2fs%s]" % (_console_yellow, time, _console_normal)
    result = test.result
    if expected and expectation_match(result, expected):
        if test.success and not config.verbose:
            _out.write("%s%s..." % (_console_clear, test.id))
            _out.flush()
            return
    else:
        if test.success:
            prefix = _console_green
        elif expected and expected != "ok":
            prefix = _console_yellow
        else:
            prefix = _console_red

        if expected and not test.success:
            global _rc
            _rc = 1

        if expected:
            result += " (expected %s)" % expected
        else:
            result += " (new)"
    _out.write("%s%s%-40s %s%s%s\n" % (_console_clear, prefix, test.id, result, _console_normal, timing))
    _out.flush()


class Report:
    def __init__(self):
        self.tests   = list()
        self.summary = (0, 0)

    def add_test(self, test):
        self.tests.append(test)
        fail = not test.success
        self.summary = (self.summary[0]+1, self.summary[1]+int(fail))

    def print_summary(self):
        _out.write("%s---------------------------\n" % (_console_clear))
        _out.write("Ran %d tests, of which %s%d failed%s.\n" %
                   (self.summary[0], _console_bold, self.summary[1], _console_normal))
        _out.flush()

    def write_faillog(self, fh, config):
        for test in self.tests:
            fh.write("%-40s %s\n" % (test.id, test.result))


def make_test(environment, filename, default_factory=None):
    """Given a filename create a new Test object"""
    global _test_factories
    # Each test gets its own environment
    environment = deepcopy(environment)
    environment.filename = filename

    # Determine Tester to be used
    factory = default_factory
    for (test, tfactory) in _test_factories:
        if test(filename):
            factory = tfactory
            break
    if factory is None:
        logging.warning("Couldn't determine Test factory for '%s'" % filename)
        return None

    try:
        test = factory(environment, filename)
    except Exception as e:
        (_, _, tb) = sys.exc_info()
        logging.warning("Couldn't create test '%s': %s" % (filename, e))
        logging.info(traceback.format_exc(tb))
        return None
    if test is None:
        logging.warning("Factory returned None for test '%s'" % filename)
        return None
    if not hasattr(test, 'run'):
        logging.warning("Factory created invalid test for '%s': test object has no run method" % (filename))
        return None

    return test


def make_tests_from_dir(environment, directory):
    names = []
    for name in glob(directory+"/*"):
        names.append(os.path.normpath(name))
    for name in glob(directory+"/**/*"):
        names.append(os.path.normpath(name))
    tests = []
    for name in names:
        test = make_test(environment, name)
        if test:
            tests.append(test)
    return tests


def default_create_testset(config, args):
    tests = []
    if not args:
        args = config.default_dirs + config.arch_dirs

    for arg in args:
        if os.path.isdir(arg):
            tests += make_tests_from_dir(config, arg)
        else:
            test = make_test(config, arg)
            if test:
                tests.append(test)
    # Sort tests by their name
    tests.sort(key=lambda x: x.id)
    return tests


_default_environment.create_testset = default_create_testset


def run_test(test):
    try:
        test.run()
    except Exception as e:
        (_, _, tb) = sys.exc_info()
        logging.error("Exception in %s: %s\n%s" % (test.id, e, traceback.format_exc(tb)))
        raise e
    return test


def makereport(environment, args):
    ensure_dir(environment.reportdir)
    ensure_dir(environment.builddir)

    expectations = {}
    if environment.expect_url:
        try:
            expectations = load_expectations(environment.expect_url, environment)
        except Exception as e:
            _out.write("Couldn't load fail expectations: %s\n" % e)

    tests = environment.create_testset(environment, args)

    # create test futures for parallel evaluation
    queue    = list()
    executor = ThreadPoolExecutor(max_workers=environment.threads)
    for test in tests:
        queue.append(executor.submit(run_test, test))

    # collect report
    r = Report()
    try:
        found = {}
        for promise in queue:
            test           = promise.result()
            found[test.id] = True
            expected       = expectations.get(test.id)
            console_output(environment, test, expected)
            r.add_test(test)
        if environment.show_disappeared:
            for t in expectations:
                if t not in found:
                    _out.write("%s%-40s %s%s\n" % (_console_red, t, "test disappeared", _console_normal))
                    _out.flush()

    except KeyboardInterrupt:
        _out.write("Received interrupt signal, shutting down\n")
        for promise in queue:
            promise.cancel()
        executor.shutdown(wait=False)
    faillog_out = environment.faillog_out
    if faillog_out is None:
        faillog_out = environment.reportdir + "/" + _report_name + ".faillog"
    r.write_faillog(open(faillog_out, 'w'), environment)
    r.print_summary()


class ConfigurationAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        callback = _configurations[self.dest]
        callback(parser, namespace, values, option_string)


def register_test_factories(plugin):
    global _test_factories
    global _configurations
    global _argparser

    if hasattr(plugin, "test_factories"):
        _test_factories += plugin.test_factories
    if hasattr(plugin, "configurations"):
        for (config, setup) in plugin.configurations.iteritems():
            if config in _configurations:
                logging.warning("Warning: plugin '%s' provides a second configuration for '%s'" % (plugin.__file__, config))
                continue
            _configurations[config] = setup
    if hasattr(plugin, "register_arguments"):
        try:
            plugin.register_arguments(_argparser)
        except Exception as e:
            (_, _, tb) = sys.exc_info()
            logging.error("Warning: loading plugin '%s' failed: %s\n%s" % (plugin.__file__, e, traceback.format_exc(tb)))


def try_load_plugin(filename):
    # do not clutter our plugin directories with .pyc files...
    sys.dont_write_bytecode = True

    try:
        dirname      = os.path.dirname(filename)
        basename     = os.path.basename(filename)
        parentmodule = dirname.replace("/", ".")
        if parentmodule not in sys.modules.keys():
            try:
                __import__(parentmodule)
            except:
                # Create a fake module
                module = imp.new_module(parentmodule)
                sys.modules[parentmodule] = module
        modulename = "%s.%s" % (parentmodule, basename.replace(".py", ""))
        with open(filename, "r") as file:
            plugin = imp.load_module(modulename, file, filename,
                                     ("py", "r", imp.PY_SOURCE))
            return plugin
    except Exception as e:
        (_, _, tb) = sys.exc_info()
        logging.error("Warning: loading plugin '%s' failed: %s\n%s" % (filename, e, traceback.format_exc(tb)))


def main():
    global _rc
    os.putenv("LC_ALL", "C")  # normalize environment
    log = logging.getLogger()

    # Load plugins
    pluginlist  = []
    pluginlist += list(glob("plugins/*.py"))
    pluginlist += list(glob("reportplugin.py"))
    pluginlist += list(glob("**/reportplugin.py"))
    pluginlist += list(glob("configs/*.py"))
    if os.path.normpath(sys.path[0]) != os.path.normpath(os.getcwd()):
        pluginlist += list(glob(sys.path[0]+"/plugins/*.py"))
        pluginlist += list(glob(sys.path[0]+"/configs/*.py"))
    for pluginname in pluginlist:
        plugin = try_load_plugin(pluginname)
        if plugin:
            register_test_factories(plugin)
    global _test_factories

    # Load main testsuite
    testsuite = None
    if os.path.exists("./testsuite.py"):
        testsuite = try_load_plugin("./testsuite.py")
        if not hasattr(testsuite, "name"):
            logging.error("%s: error: Skipping testsuite without name")
            testsuite = None
        register_test_factories(testsuite)

    # Add new commandline options for all configurations
    for (config, setupfunc) in sorted(_configurations.items()):
        _argparser.add_argument("--%s" % config, dest=config, nargs=0,
                                action=ConfigurationAction,
                                help="activate %s configuration" % config)

    _test_factories += annotated_test_factories
    environment = deepcopy(_default_environment)
    if hasattr(testsuite, "environment"):
        environment.merge(testsuite.environment)
    default_tests = environment.tests
    _argparser.parse_args(namespace=environment)
    if len(environment.tests) == 0:
        environment.tests = default_tests
    if environment.debug:
        log.setLevel(logging.INFO)
    makereport(environment, environment.tests)
    return _rc


if __name__ == "__main__":
    sys.exit(main())
